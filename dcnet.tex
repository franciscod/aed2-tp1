\begin{tad}{\tadNombre{DCNet}}
	\tadGeneros{dcnet}

	\tadAlinearFunciones{compuQueMasEnvio}{dcnet/dcn,pc/p1,pc/p2,paquete}
	\tadIgualdadObservacional{d}{d'}{dcnet}{$ (topo(d) \igobs topo(d')) \land \newline
		((\forall p: pc)(p \in compus(topo(d)) \land   p \in compus(topo(d')) \impluego  \newline
		(buffer(d,p) \igobs buffer(d',p) \land \newline
		\#paquetesEnviados(d,p) \igobs \#paquetesEnviados(d',p) )\land \newline
		((\forall p: paquetes)((\exists  c: pc )(c \in compus(topo(d') \land \newline 
		c \in compus(topo(d') ) \yluego(p \in buffer(d,c) \land \newline
		p \in buffer(d',c) ) )\impluego \newline
		( recorridoPaquete(d,p) \igobs recorridoPaquete(d',p) ) ) $}
	\tadGeneradores
	\tadOperacion{CrearRed}{topo}{dcnet}{}
	\tadOperacion{Seg}{dcnet}{dcnet}{}
	\tadOperacion{CrearPaquete}{dcnet/dcn,pc/p1,pc/p2,paquete}{dcnet}
	{$(p_1 \in compus(topo(dcn)) \land  p_2 \in compus(topo(dcn))) \yluego  conectadas?(topo(dcn) , p_1 , p_2)$}

	\tadObservadores
	
	\tadOperacion{topo}{dcnet}{topologia}{}
	\tadOperacion{$\#$paquetesEnviados}{dcnet/dcn,pc/p}{nat}{$p$ $\in$ compus(topo($dcn$))}
	\tadOperacion{buffer}{dcnet/dcn,pc/p}{conj(paquete)}{$p$ $\in$ compus(topo($dcn$))}
	


	\tadOtrasOperaciones

	\tadOperacion{recorridoPaquete}{dcnet/dcn,nat/id}{secu(tupla(nat, nat, nat, nat)))}{$(paqueteEnTransito?(dcn, id)$}
	\tadOperacion{cortarRecHasta}{sec(tupla(nat, nat, nat, nat)), nat}{sec(tupla(nat, nat, nat, nat))}{}

	\tadOperacion{buscarPaquete}{dcnet/dcn, conj(nat)/pcs, nat/id}{nat}{pcs = compus(topo(dcn)) $\land$ ($\exists$ ip : nat)(ip $\in$ pcs $\land$ id $\in$ buffer(dcn, ip))}
	\tadOperacion{$\Pi_1$Conj}{{conj(tupla(nat, nat, nat, nat))}}{conj(nat))}{}

	\tadOperacion{paqueteEnTransito?}{dcnet, nat}{bool}{}
	\tadOperacion{existePaqEnBuffers?}{dcnet/dcn, conj(nat)/pcs, nat/id}{bool}{pcs = compus(topo(dcn))}

	


	\tadOperacion{perteneceBuffers?}{paquete,buffers}{bool}{}


	\tadOperacion{darPaqueteEnviado}{conj(paquete)}{paquete}{}

	\tadOperacion{darPrioridad}{dcnet/dcn,nat/id}{nat}{$id \in paquetesEnLaRed(dcn)$ }
	\tadOperacion{buscarPrioridad}{nat,conj(paquetes)}{nat}{}
	\tadOperacion{maxPrioridad}{dcnet,conj(pc)}{nat}{}
	\tadOperacion{PaquetesConPrioridadK}{dcnet,conj(pc),nat}{paquete}{}


	\tadOperacion{paquetesEnLaRed}{dcnet)}{conj(paquete)}{}
	\tadOperacion{buscarPaquetesEnLaRed}{dcnet,conj(pc))}{conj(paquete)}{}

	\tadOperacion{compuQueMasEnvio}{dcnet}{pc}{}
	\tadOperacion{laQueMasEnvio}{dcnet,conj(pc)}{pc)}{}

	

	
	\tadOperacion{pasoSeg}{topo,buffers,buffers}{buffers}{}
	\tadOperacion{regresion}{topo,buffers,secu(buffers)}{buffers}{}
	\tadOperacion{generarHistoria}{dcnet,diccionario(pc,conj(paquete))}{secu(buffers)}{}
	\tadOperacion{auxDefinir}{buffers,pc,conj(paquete),conj(paquete)}{buffers}{}
	\tadOperacion{auxBorrar}{buffers,pc,conj(paquete),conj(paquete)}{buffers}{}
	\tadOperacion{transacion}{topo,buffers,conj(pc)}{buffers}{}
	\tadOperacion{envio}{topo,buffers,ip,conj(paquete)}{buffers}{}
	\tadOperacion{nuevosPaquetes}{buffers,buffers}{buffers}{}
	

	\tadOperacion{pasarA}{topologia,pc,pc}{pc}{}

	\tadAlinearAxiomas{$\#$paquetesEnviados(CrearPaquete(dcn,o,d,p),c)}

	\tadAxiomas[\paratodo{paquete}{p,p'},\paratodo{pc}{c,c'},\paratodo{dcnet}{dcn},\paratodo{topologia}{t}]

	\tadAxioma{topo(crearRed(t))}{t}
	\tadAxioma{topo(seg(dcn))}{topo(dcn)}
	\tadAxioma{topo(CrearPaquete(dcn,c,c',p))}{topo(dcn)}


	
	

	\tadAxioma{$\#$paquetesEnviados(crearRed(t),c)}{0}
	\tadAxioma{$\#$paquetesEnviados(seg(dcn),c)}{$\#$paquetesEnviados(dcn)}
	\tadAxioma{$\#$paquetesEnviados(CrearPaquete(dcn,o,d,p),c)}{\IF $c = o$ THEN $\#paquetesEnviados(dcn,c) + 1$ ELSE $\#paquetesEnviados(dcn,c)$ FI}

	\tadAxioma{buffer(dcn,c)}{obtener(c,regresion(topo(dcn),vacio,generarHistoria(dcn,vacio)))}

	\tadAxioma{recorridoPaquete(dcn, p)}{
		cortarRecHasta(darCaminoMasCorto(topo(dcn), \\origen(p), destino(p)), buscar(compus(topo(dcn)), p))
	}
	\tadAxioma{cortarRecHasta(s, ip)}{
		\IF vacia?(s) $\oluego$ ip = ipOrigen(prim(s)) THEN <> 		% ipOrigen es el primer elemento del segmento
		ELSE prim(s) \puntito cortarRecHasta(fin(s), ip)
		FI
	}
	\tadAxioma{buscarPaquete(dcn, compus, id)}{
		\IF id $\in$ $\Pi_1$Conj(buffer(dcn, dameUno(compus))) THEN dameUno(compus)
		ELSE buscarPaquete(sinUno(compus), id)
		FI
	}
	\tadAxioma{$\Pi_1$Conj($conjTuplas$)}{
		\IF $\emptyset$?($conjTuplas$) THEN
			$\emptyset$
		ELSE
			Ag($\Pi_1$(dameUno($conjTuplas$)), $\Pi_1$Conj(sinUno($conjTuplas$)))
		FI
	}

	\tadAxioma{paqueteEnTransito?(dcn, id)}{
		existePaqEnBuffers?(dcn, compus(topo(dcn)), id)
	}
	\tadAxioma{existePaqEnBuffers?(dcn, pcs, id)}{
		\IF $\emptyset$?(pcs) THEN false
		ELSE {
			\IF id $\in$ $\Pi_1$Conj(buffer(dcn, dameUno(pcs))) THEN true
			ELSE existePaqEnBuffers?(dcn, sinUno(pcs), id)
			FI
		}
		FI
	}


	\tadAxioma{buscarpaquetesEnLaRed(dcn,cc)}{\IF $\emptyset?(cc)$ THEN 
													$\emptyset$ 
												ELSE 
													$ buffer(dcn,dameUno(cc)) \cup buscarpaquetesEnLaRed(dcn,sinUno(cc))$
												FI}

	\tadAxioma{paquetesEnLaRed(dcn)}{$buscarpaquetesEnLaRed(dcn,compus(topo(dcn)))$}
	\tadAxioma{buscarPrioridad(id,cp)}{\IF $i = \Pi_1(dameUno(cp))$ THEN $\Pi_4(dameUno(cp))$ ELSE $ darPrioridad(id,sinUno(cp))$ FI}

	\tadAxioma{darPrioridad(dcn,id)}{$buscarPrioridad(id,compus(dcn))$}
	
	\tadAxioma{darPaqueteEnviado(dcn,cp)}{$dameUno(PaquetesConPrioridadK$
											$(dcn,cp,maxPrioridad(dcn,cp)))$}
	\tadAxioma{maxPrioridad(dcn,cp)}{\IF $\emptyset?(sinUno(cp))$ THEN 
											$darPrioridad(dcn,dameUno(cp)$
										ELSE 
											$max(darPrioridad(dcn,dameUno(cp),$
											$maxPrioridad(dcn,sinUno(cp)))$
										FI}
	
	\tadAxioma{PaquetesConPrioridadK(dcn,cp,k)}{	\IF $\emptyset?(cp)$ THEN 
													$\emptyset$
												ELSE{\IF $ darPrioridad(dcn,dameUno(cp)) = k$ THEN 	
														$ Ag(dameUno(cp),PaquetesConPrioridadK$
														$(dcn,sinUno(cp),k))$
													ELSE
														$PaquetesConPrioridadK(dcn,sinUno(cp),k)$
													FI}		
											FI}



	\tadAxioma{compuQueMasEnvio(dcn)}{laQueMasEnvio(dcn,compus(topo(dcn)))}
	\tadAxioma{laQueMasEnvio(dcn,cs)}{\IF $\emptyset?(sinUno(cs))$ THEN 
											$dameUno(cs)$ 
										ELSE { \IF $\#paquetesEnviados(dcn,dameUno(cs)<$
													$\#paquetesEnviados(dcn,laQueMasEnvio$
													$(dcn,sinUno(cs))) $ THEN
													$laQueMasEnvio(dcn,sinUno(cs))$
												ELSE
													$dameUno(cs)$
												FI}
										FI}

	
	\tadAxioma{perteneceBuffers?(p,bs)}{\IF $\emptyset?(claves(bs))$ THEN 
											$false$ 
										ELSE { \IF $p \in obtener(dameUno(claves(bs)),bs)$ THEN
													$true$
												ELSE 
													$perteneceBuffers?(p,borrar(dameUno(claves(bs)),bs))$
												FI
											}	
										FI}



	\tadAxioma{generarHistoria(crearRed(t),bs)}{bs \puntito <>}
	\tadAxioma{generarHistoria(seg(dcn),bs)}{ bs \puntito generarHistoria(dcn,$vac√≠o$) }
	\tadAxioma{generarHistoria(CrearPaquete(dcn,o,d,p),bs)}{ \IF $def?(c,bs)$ THEN 
																	$generarHistoria(dcn,definir(c,n \cup obtener(o,bs),bs))$
																ELSE 
																	$generarHistoria(dcn,definir(c,n))$ 
																FI}

	\tadAxioma{auxBorrar(bs,c,b,p)}{\IF $\emptyset?(p - \{ b \})$ THEN $borrar(c,n)$ 
										ELSE $borrar(c,bs) \ \ definir(c,p - \{ b \},bs)$  FI 
	}

	\tadAxioma{regresion(t,bs,cbs)}{\IF $vacia?(fin(cbs))$ THEN $ pasoSeg(bs,t,prim(cbs))$ ELSE $ regresion(t,pasoSeg(bs,t,prim(cbs)),fin(cbs))$ FI}
	\tadAxioma{pasoSeg(t,bs,nbs)}{nuevosPaquetes(transacion(t,bs,claves(bs)) ,nbs)}
	\tadAxioma{transacion(t,bs,cp)}{\IF $\emptyset?(cp)$ THEN 
												$bs$ 
											ELSE 
												$transacion(t,envio(t,bs,dameUno(cp)),$
												$sinUno(cp))$ 
											FI}
	\tadAxioma{pasarA(t,o,d)}{$prim(caminoMin(t,o,d))$}												
	\tadAxioma{envio(t,bs,ip,cp)}{\IF $\emptyset?(darPaqueteEnviado(cp))$ THEN
								$bs$
								ELSE{ \IF $pasarA(t,ip,destino(darPaqueteEnviado(cp))) = destino(darPaqueteEnviado(cp)))$ THEN
											$envio(t,quitarPaquete(bs,ip),ip,cp -{darPaqueteEnviado(cp)}))$
									    ELSE
											$envio(t,quitarPaquete(pasarPaquete(bs,ip,darPaqueteEnviado(cp)),ip)$
											$,ip,cp -{darPaqueteEnviado(b)} ))$
										FI}
								FI}

	\tadAxioma{nuevosPaquetes(bs,nbs)}{\IF $\emptyset?(claves(nbs))$ THEN 
										 $bs$  
										ELSE  
										 	$nuevosPaquetes(auxDefinir(bs,dameUno(claves(nbs),obtener$ 
										 	$(dameUno(claves(nbs),nbs),obtener(dameUno$  
										 	$(claves(nbs),bs))),sinUno(nbs))$	
										FI}
\end{tad}
